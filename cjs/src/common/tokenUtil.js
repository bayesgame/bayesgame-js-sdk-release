"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("../erc165.js"),r=require("../erc20.js"),e=require("../erc721.js"),a=require("../erc1155.js"),n=require("ethers"),o=require("./format.js"),s=require("../multicall.js");exports.TokenUtil=class{constructor(t){this.chain=t}async getTokenStandard(r){const e=new t.ERC165(this.chain,r);if(await e.supportsInterface("0x80ac58cd")||await e.supportsInterface("0x5b5e139f"))return"erc721";if(await e.supportsInterface("0xd9b67a26")||await e.supportsInterface("0x0e89341c"))return"erc1155";throw new Error("unknown contract standard address "+r)}async infoForERC20(t){const e=new r.ERC20(this.chain,t);return await e.info()}async infoForERC20s(t){const r=await Promise.all(t.map((t=>this.infoForERC20(t)))),e={};for(let t of r)e[t.address]=t;return e}async allownceForERC20s(t,r,e,a=""){if(!t.length)throw new Error("no token address");if(!r)throw new Error("no user");if(!e)throw new Error("no operator");const o={},i=this.chain.getNativeAddr();if(t.includes(i)&&(o[i]=n.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff").toString()),t.map(((r,e)=>{this.chain.isZeroAddress(r)&&t.splice(e,1)})),!t.length)return o;const f=[];for(let a=0;a<t.length;a++){const n=await this._wrapAllownceInfoForERC20CallData(t[a],r,e);f.push(n)}const c=await s.multicall(this.chain,f);for(let r=0;r<c.length;r++){o[t[r].toLowerCase()]=n.BigNumber.from(c[r]).toString()}return o}async balanceForERC20s(t,r){if(!t.length)throw new Error("no token address");r||(r=await this.chain.getAccount());const e={},a=this.chain.getNativeAddr();if(t.includes(a)&&(e[a]=await this.chain.getBalance(r)),t.map(((r,e)=>{this.chain.isZeroAddress(r)&&t.splice(e,1)})),!t.length)return e;const o=[];for(let e=0;e<t.length;e++){const a=await this._wrapBalanceInfoForERC20CallData(r,t[e]);o.push(a)}const i=await s.multicall(this.chain,o);for(let r=0;r<i.length;r++)e[t[r].toLowerCase()]=n.BigNumber.from(i[r]).toString();return e}async balanceInfoForERC1155(t,r,e){if(!t.length||!r.length||t.length!=r.length)throw new Error("invalid pramaters");const a=[];for(let n=0;n<t.length;n++){const o=await this._wrapBalanceInfoForERC1155CallData(e[n],t[n],r[n]);a.push(o)}const o={},i=await s.multicall(this.chain,a);for(let a=0;a<i.length;a++){o[t[a].toLowerCase()+"-"+r[a]+"-"+e[a].toLowerCase()]=n.BigNumber.from(i[a]).toString()}return o}async ownerOfInfoForERC721(t,r,e){if(!t.length||!r.length||!e.length||t.length!=r.length||t.length!=e.length)throw new Error("invalid pramaters");const a=[];for(let e=0;e<t.length;e++){const n=await this._wrapOwnerOfInfoForERC721CallData(t[e],r[e]);a.push(n)}const n={},i=await s.multicall(this.chain,a);for(let a=0;a<i.length;a++){const s=e[a].toLowerCase()===o.formatAddress(i[a]).toLowerCase();n[t[a].toLowerCase()+"-"+r[a]+"-"+e[a].toLowerCase()]=s}return n}async estimateGasApproveForERC20(t,e){if(!t)throw new Error("no token address");if(!e)throw new Error("no operator");const a=new r.ERC20(this.chain,t).approve(e),o=await a.estimateGas();return n.BigNumber.from(o).toString()}async estimateGasApproveForERC20s(t,r){if(!t.length)throw new Error("no token address");if(!r)throw new Error("no operator");const e={};for(let a=0;a<t.length;a++){const n=t[a].toLowerCase();e[n]=await this.estimateGasApproveForERC20(n,r)}return e}async _wrapAllownceInfoForERC20CallData(t,e,a){return{target:t,gasLimit:0,callData:new r.ERC20(this.chain,t).allowanceEncodeFunction(e,a)}}async _wrapBalanceInfoForERC20CallData(t,e){return{target:e,gasLimit:0,callData:new r.ERC20(this.chain,e).balanceOfEncodeFunction(t)}}async _wrapBalanceInfoForERC1155CallData(t,r,e){return{target:r,gasLimit:0,callData:new a.ERC1155(this.chain,r).balanceOfEncodeFunction(t,e)}}async _wrapOwnerOfInfoForERC721CallData(t,r){return{target:t,gasLimit:0,callData:new e.ERC721(this.chain,t).ownerOfEncodeFunction(r)}}};
