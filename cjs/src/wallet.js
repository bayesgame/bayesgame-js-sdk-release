"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("ethers"),n=require("./chain.js");require("../node_modules/.pnpm/@0xsequence_multicall@0.41.3/node_modules/@0xsequence/multicall/dist/0xsequence-multicall.esm.js"),require("./bayesgame/network.js"),require("../node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs.js");var t=require("./constants.js"),o=require("../node_modules/.pnpm/@walletconnect_client@1.8.0/node_modules/@walletconnect/client/dist/cjs/index.js"),s=require("../node_modules/.pnpm/@walletconnect_qrcode-modal@1.8.0/node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js");class c extends n.BrowserChain{constructor(){super(),this.tryCount=0,this.ethereum=null,this.chainInstalled=!1,this.chainStatusHandles=[],this.chainHandles=[],this.accountsHandles=[],this.connector=null,this.accounts=[],this.account="",this.chainIdWhiteList=[]}setSession(e,n){void 0!==n&&"undefined"!=typeof sessionStorage&&sessionStorage.setItem(e,n)}getSession(e){return"undefined"!=typeof sessionStorage?sessionStorage.getItem(e):""}isConnected(){return console.log("isConnected"),!(!this.connector||!this.connector.connected)||!!this.chainInstalled&&this.accounts.length>0}onChainStatus(e){this.chainStatusHandles.push(e)}onAccountsChanged(e){console.log("ChainWallet onAccountsChanged:",this.accountsHandles),this.accountsHandles.push(e)}onChainChanged(e){this.chainHandles.push(e)}connect(e="",n=[]){if(this.chainIdWhiteList=n,e||(e=this.getSession("chainClient"))||(e="m"),this.isConnected())return console.log("Wallet isConnected"),Promise.resolve(this.accounts);if(console.debug("Wallet connect to:",e),this.setSession("chainClient",e),this.tryCount=0,"m"===e){if(this.connectMetamask(),!this.chainInstalled)return console.debug("No Provider!"),Promise.reject("No Provider!")}else if("b"===e){if(this.connectBinance(),!this.chainInstalled)return console.debug("No Provider!"),Promise.reject("No Provider!")}else if("tp"===e){if(this.connectTokenPocket(),!this.chainInstalled)return console.debug("No Provider!"),Promise.reject("No Provider!")}else{if("w"===e)return Promise.resolve(this.connectWalletConnect());if("o"===e){if(this.connectOnto(),!this.chainInstalled)return console.debug("No Provider!"),Promise.reject("No Provider!")}else if("okx"===e&&(this.connectOKX(),!this.chainInstalled))return console.debug("No Provider!"),Promise.reject("No Provider!")}return this.chainInstalled?this.ethereum.request({method:"eth_requestAccounts"}).then((e=>(console.debug("connect accounts",e),this._handleNewAccounts(e),e))):void 0}async disconnect(){try{return this.connector&&this.connector.connected&&(console.debug("disconnect connector"),this.connector.killSession()),this.chainInstalled=!1,this._handleNewAccounts([]),!0}catch(e){return e}}connectWalletConnect(){this.connector=new o.default({bridge:"https://bridge.walletconnect.org",qrcodeModal:s.default});let e=[];return this.connector.connected?(e=this.connector.accounts,console.debug("walletconnect connected:",e),this._handleChainStatus(!0),this._handleNewAccounts(e)):(console.debug("walletconnect..."),this.connector.createSession(),this.connector.on("connect",((n,t)=>{console.debug("on connect");const{accounts:o,chainId:s}=t.params[0];e=o,this._handleNewChain(s),this._handleChainStatus(!0),this._handleNewAccounts(o)})),this.connector.on("session_update",((e,n)=>{const{accounts:t,chainId:o}=n.params[0];console.debug("walletconnect accounts:",t),this._handleNewChain(o),this._handleNewAccounts(t)})),this.connector.on("disconnect",((e,n)=>{console.debug("walletconnect disconnect"),this._handleNewAccounts([])}))),console.debug("walletconnect account:",e),e}connectMetamask(){"undefined"!=typeof window&&(window.ethereum?this._chainConnected():(console.debug("not found Metamask"),this.tryCount<1?setTimeout((()=>{console.debug("try to connect Metamask"),this.connectMetamask(),this.tryCount++}),2e3):(console.debug("not found Metamask, timeout"),this._handleChainStatus(!1))))}connectTokenPocket(){"undefined"!=typeof window&&(window.tokenpocket?this._chainConnected(window.tokenpocket.ethereum):(console.debug("not found TokenPocket"),this.tryCount<1?setTimeout((()=>{console.debug("try to connect TokenPocket"),this.connectTokenPocket(),this.tryCount++}),2e3):(console.debug("not found TokenPocket, timeout"),this._handleChainStatus(!1))))}connectOKX(){"undefined"!=typeof window&&(window.okexchain?(this.ethereum=window.okexchain,this._chainConnected()):(console.debug("not found OKX"),this.tryCount<1?setTimeout((()=>{this.connectOKX(),this.tryCount++}),2e3):(console.debug("not found OKX, timeout"),this._handleChainStatus(!1))))}connectBinance(){"undefined"!=typeof window&&(window.BinanceChain?this._chainConnected(window.BinanceChain):(console.debug("not found Binance"),this.tryCount<1?setTimeout((()=>{this.connectBinance(),this.tryCount++}),2e3):(console.debug("not found Binance, timeout"),this._handleChainStatus(!1))))}connectOnto(){"undefined"!=typeof window&&(window.onto?this._chainConnected():(console.debug("not found onto"),this.tryCount<1?setTimeout((()=>{this.connectOnto(),this.tryCount++}),2e3):(console.debug("not found onto, timeout"),this._handleChainStatus(!1))))}addToken(e,n,t){const o=this.ethereum;return new Promise(((s,c)=>{o.request({method:"wallet_watchAsset",params:{type:"ERC20",options:{address:e,symbol:n,decimals:t,image:""}}}).then((n=>{if(!n)throw c(),new Error("Something went wrong.");s(e),console.debug("successfully added to wallet!")})).catch((()=>{c()}))}))}async switchNetwork(e){const n=this.ethereum;if(e&&n)try{return await n.request({method:"wallet_switchEthereumChain",params:[{chainId:`0x${e.toString(16)}`}]}),!0}catch(o){if(4902===(null==o?void 0:o.code))try{const o=[t.CHAIN_RPC[e]];return await n.request({method:"wallet_addEthereumChain",params:[{chainId:`0x${e.toString(16)}`,chainName:t.CHAIN_NAME[e],nativeCurrency:{name:t.CHAIN_SYMBOL.ZeroToken[e],symbol:t.CHAIN_SYMBOL.ZeroToken[e].toLowerCase(),decimals:18},rpcUrls:o,blockExplorerUrls:[t.CHAIN_BROWSER[e]]}]}),!0}catch(e){return console.error("Failed to setup the network",e),!1}return!1}return!1}_chainConnected(n){if("undefined"==typeof window)return;console.debug("chain connected userAgent:",navigator.userAgent),this.chainInstalled=!0,this.ethereum=n||window.ethereum,-1==navigator.userAgent.indexOf("Mobile")&&(console.debug("chain connected on event"),this.ethereum.on("chainChanged",this._handleNewChain.bind(this)),this.ethereum.on("accountsChanged",this._handleNewAccounts.bind(this))),this._handleChainStatus(!0),console.debug("chain installed:",this.chainInstalled),console.debug("chain client:",this.getSession("chainClient"));const t=new e.ethers.providers.Web3Provider(window.ethereum);this.setProvider(t),this.ethereum.chainId?(console.debug("ethereum chainid",this.ethereum.chainId),this._handleNewChain(this.ethereum.chainId)):t.getNetwork().then((e=>{console.debug("web chainid",e),this._handleNewChain(e)})).catch((e=>{console.error("chainid except:",e)}))}_handleNewChain(n){if("object"==typeof n&&(null==n?void 0:n.chainId)&&(n=n.chainId),!n)return void console.debug("disconnect before chain:",this.chainId);let t=Number(n);console.debug("handle chain:",this.chainId,t),this.chainId!==t&&this.clean(),this.chainId=t;try{const n=new e.ethers.providers.Web3Provider(window.ethereum);this.setProvider(n)}catch(e){console.error("no providers")}for(const[,e]of this.chainHandles.entries())e(n);!this.chainIdWhiteList.length||this.chainIdWhiteList.includes(this.chainId)?(console.debug("connect contract"),this.connectContract()):console.warn("no support chain id",this.chainId)}_handleChainStatus(e){console.debug("handle chain status:",e);for(const[,n]of this.chainStatusHandles.entries())n(e)}_handleNewAccounts(e){console.debug("handle accounts:",e),this.accounts=e,e&&e.length>0?this.account=e[0]:this.account="";for(const[,n]of this.accountsHandles.entries())n(e)}}const i=new c;exports.ChainWallet=c,exports.LocalWallet=class{static fromPrivateKey(n){return new e.Wallet(n)}},exports.chainWallet=i;
