"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("events"),t=require("https"),r=require("http"),o=require("net"),s=require("tls"),i=require("crypto"),n=require("url"),a=require("./permessage-deflate.js"),c=require("./receiver.js"),d=require("./sender.js"),h=require("./constants.js"),u=require("./event-target.js"),l=require("./extension.js"),_=require("./buffer-util.js");function p(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var f,m,S=p(e),y=p(t),v=p(r),b=p(o),N=p(s),O=p(i),C=p(n);exports.__require=function(){if(m)return f;m=1;const e=S.default,t=y.default,r=v.default,o=b.default,s=N.default,{randomBytes:i,createHash:n}=O.default,{URL:p}=C.default,g=a.__require(),E=c.__require(),k=d.__require(),{BINARY_TYPES:x,EMPTY_BUFFER:w,GUID:L,kStatusCode:I,kWebSocket:P,NOOP:T}=h.__require(),{addEventListener:q,removeEventListener:G}=u.__require(),{format:j,parse:W}=l.__require(),{toBuffer:D}=_.__require(),R=["CONNECTING","OPEN","CLOSING","CLOSED"],M=[8,13];class A extends e{constructor(e,t,r){super(),this._binaryType=x[0],this._closeCode=1006,this._closeFrameReceived=!1,this._closeFrameSent=!1,this._closeMessage="",this._closeTimer=null,this._extensions={},this._protocol="",this._readyState=A.CONNECTING,this._receiver=null,this._sender=null,this._socket=null,null!==e?(this._bufferedAmount=0,this._isServer=!1,this._redirects=0,Array.isArray(t)?t=t.join(", "):"object"==typeof t&&null!==t&&(r=t,t=void 0),F(this,e,t,r)):this._isServer=!0}get binaryType(){return this._binaryType}set binaryType(e){x.includes(e)&&(this._binaryType=e,this._receiver&&(this._receiver._binaryType=e))}get bufferedAmount(){return this._socket?this._socket._writableState.length+this._sender._bufferedBytes:this._bufferedAmount}get extensions(){return Object.keys(this._extensions).join()}get onclose(){}set onclose(e){}get onerror(){}set onerror(e){}get onopen(){}set onopen(e){}get onmessage(){}set onmessage(e){}get protocol(){return this._protocol}get readyState(){return this._readyState}get url(){return this._url}setSocket(e,t,r){const o=new E(this.binaryType,this._extensions,this._isServer,r);this._sender=new k(e,this._extensions),this._receiver=o,this._socket=e,o[P]=this,e[P]=this,o.on("conclude",Y),o.on("drain",H),o.on("error",K),o.on("message",J),o.on("ping",Q),o.on("pong",X),e.setTimeout(0),e.setNoDelay(),t.length>0&&e.unshift(t),e.on("close",Z),e.on("data",ee),e.on("end",te),e.on("error",re),this._readyState=A.OPEN,this.emit("open")}emitClose(){if(!this._socket)return this._readyState=A.CLOSED,void this.emit("close",this._closeCode,this._closeMessage);this._extensions[g.extensionName]&&this._extensions[g.extensionName].cleanup(),this._receiver.removeAllListeners(),this._readyState=A.CLOSED,this.emit("close",this._closeCode,this._closeMessage)}close(e,t){if(this.readyState!==A.CLOSED){if(this.readyState===A.CONNECTING){const e="WebSocket was closed before the connection was established";return B(this,this._req,e)}this.readyState!==A.CLOSING?(this._readyState=A.CLOSING,this._sender.close(e,t,!this._isServer,(e=>{e||(this._closeFrameSent=!0,(this._closeFrameReceived||this._receiver._writableState.errorEmitted)&&this._socket.end())})),this._closeTimer=setTimeout(this._socket.destroy.bind(this._socket),3e4)):this._closeFrameSent&&(this._closeFrameReceived||this._receiver._writableState.errorEmitted)&&this._socket.end()}}ping(e,t,r){if(this.readyState===A.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");"function"==typeof e?(r=e,e=t=void 0):"function"==typeof t&&(r=t,t=void 0),"number"==typeof e&&(e=e.toString()),this.readyState===A.OPEN?(void 0===t&&(t=!this._isServer),this._sender.ping(e||w,t,r)):V(this,e,r)}pong(e,t,r){if(this.readyState===A.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");"function"==typeof e?(r=e,e=t=void 0):"function"==typeof t&&(r=t,t=void 0),"number"==typeof e&&(e=e.toString()),this.readyState===A.OPEN?(void 0===t&&(t=!this._isServer),this._sender.pong(e||w,t,r)):V(this,e,r)}send(e,t,r){if(this.readyState===A.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if("function"==typeof t&&(r=t,t={}),"number"==typeof e&&(e=e.toString()),this.readyState!==A.OPEN)return void V(this,e,r);const o={binary:"string"!=typeof e,mask:!this._isServer,compress:!0,fin:!0,...t};this._extensions[g.extensionName]||(o.compress=!1),this._sender.send(e||w,o,r)}terminate(){if(this.readyState!==A.CLOSED){if(this.readyState===A.CONNECTING){const e="WebSocket was closed before the connection was established";return B(this,this._req,e)}this._socket&&(this._readyState=A.CLOSING,this._socket.destroy())}}}function F(e,o,s,a){const c={protocolVersion:M[1],maxPayload:104857600,perMessageDeflate:!0,followRedirects:!1,maxRedirects:10,...a,createConnection:void 0,socketPath:void 0,hostname:void 0,protocol:void 0,timeout:void 0,method:void 0,host:void 0,path:void 0,port:void 0};if(!M.includes(c.protocolVersion))throw new RangeError(`Unsupported protocol version: ${c.protocolVersion} (supported versions: ${M.join(", ")})`);let d;o instanceof p?(d=o,e._url=o.href):(d=new p(o),e._url=o);const h="ws+unix:"===d.protocol;if(!(d.host||h&&d.pathname))throw new Error(`Invalid URL: ${e.url}`);const u="wss:"===d.protocol||"https:"===d.protocol,l=u?443:80,_=i(16).toString("base64"),f=u?t.get:r.get;let m;if(c.createConnection=u?U:$,c.defaultPort=c.defaultPort||l,c.port=d.port||l,c.host=d.hostname.startsWith("[")?d.hostname.slice(1,-1):d.hostname,c.headers={"Sec-WebSocket-Version":c.protocolVersion,"Sec-WebSocket-Key":_,Connection:"Upgrade",Upgrade:"websocket",...c.headers},c.path=d.pathname+d.search,c.timeout=c.handshakeTimeout,c.perMessageDeflate&&(m=new g(!0!==c.perMessageDeflate?c.perMessageDeflate:{},!1,c.maxPayload),c.headers["Sec-WebSocket-Extensions"]=j({[g.extensionName]:m.offer()})),s&&(c.headers["Sec-WebSocket-Protocol"]=s),c.origin&&(c.protocolVersion<13?c.headers["Sec-WebSocket-Origin"]=c.origin:c.headers.Origin=c.origin),(d.username||d.password)&&(c.auth=`${d.username}:${d.password}`),h){const e=c.path.split(":");c.socketPath=e[0],c.path=e[1]}let S=e._req=f(c);c.timeout&&S.on("timeout",(()=>{B(e,S,"Opening handshake has timed out")})),S.on("error",(t=>{null===S||S.aborted||(S=e._req=null,e._readyState=A.CLOSING,e.emit("error",t),e.emitClose())})),S.on("response",(t=>{const r=t.headers.location,i=t.statusCode;if(r&&c.followRedirects&&i>=300&&i<400){if(++e._redirects>c.maxRedirects)return void B(e,S,"Maximum redirects exceeded");S.abort();const t=new p(r,o);F(e,t,s,a)}else e.emit("unexpected-response",S,t)||B(e,S,`Unexpected server response: ${t.statusCode}`)})),S.on("upgrade",((t,r,o)=>{if(e.emit("upgrade",t),e.readyState!==A.CONNECTING)return;S=e._req=null;const i=n("sha1").update(_+L).digest("base64");if(t.headers["sec-websocket-accept"]!==i)return void B(e,r,"Invalid Sec-WebSocket-Accept header");const a=t.headers["sec-websocket-protocol"],d=(s||"").split(/, */);let h;if(!s&&a?h="Server sent a subprotocol but none was requested":s&&!a?h="Server sent no subprotocol":a&&!d.includes(a)&&(h="Server sent an invalid subprotocol"),h)return void B(e,r,h);a&&(e._protocol=a);const u=t.headers["sec-websocket-extensions"];if(void 0!==u){if(!m){return void B(e,r,"Server sent a Sec-WebSocket-Extensions header but no extension was requested")}let t;try{t=W(u)}catch(t){return void B(e,r,"Invalid Sec-WebSocket-Extensions header")}const o=Object.keys(t);if(o.length){if(1!==o.length||o[0]!==g.extensionName){return void B(e,r,"Server indicated an extension that was not requested")}try{m.accept(t[g.extensionName])}catch(t){return void B(e,r,"Invalid Sec-WebSocket-Extensions header")}e._extensions[g.extensionName]=m}}e.setSocket(r,o,c.maxPayload)}))}function $(e){return e.path=e.socketPath,o.connect(e)}function U(e){return e.path=void 0,e.servername||""===e.servername||(e.servername=o.isIP(e.host)?"":e.host),s.connect(e)}function B(e,t,r){e._readyState=A.CLOSING;const o=new Error(r);Error.captureStackTrace(o,B),t.setHeader?(t.abort(),t.socket&&!t.socket.destroyed&&t.socket.destroy(),t.once("abort",e.emitClose.bind(e)),e.emit("error",o)):(t.destroy(o),t.once("error",e.emit.bind(e,"error")),t.once("close",e.emitClose.bind(e)))}function V(e,t,r){if(t){const r=D(t).length;e._socket?e._sender._bufferedBytes+=r:e._bufferedAmount+=r}if(r){r(new Error(`WebSocket is not open: readyState ${e.readyState} (${R[e.readyState]})`))}}function Y(e,t){const r=this[P];r._socket.removeListener("data",ee),r._socket.resume(),r._closeFrameReceived=!0,r._closeMessage=t,r._closeCode=e,1005===e?r.close():r.close(e,t)}function H(){this[P]._socket.resume()}function K(e){const t=this[P];t._socket.removeListener("data",ee),t._socket.resume(),t.close(e[I]),t.emit("error",e)}function z(){this[P].emitClose()}function J(e){this[P].emit("message",e)}function Q(e){const t=this[P];t.pong(e,!t._isServer,T),t.emit("ping",e)}function X(e){this[P].emit("pong",e)}function Z(){const e=this[P];this.removeListener("close",Z),this.removeListener("end",te),e._readyState=A.CLOSING,e._socket.read(),e._receiver.end(),this.removeListener("data",ee),this[P]=void 0,clearTimeout(e._closeTimer),e._receiver._writableState.finished||e._receiver._writableState.errorEmitted?e.emitClose():(e._receiver.on("error",z),e._receiver.on("finish",z))}function ee(e){this[P]._receiver.write(e)||this.pause()}function te(){const e=this[P];e._readyState=A.CLOSING,e._receiver.end(),this.end()}function re(){const e=this[P];this.removeListener("error",re),this.on("error",T),e&&(e._readyState=A.CLOSING,this.destroy())}return Object.defineProperty(A,"CONNECTING",{enumerable:!0,value:R.indexOf("CONNECTING")}),Object.defineProperty(A.prototype,"CONNECTING",{enumerable:!0,value:R.indexOf("CONNECTING")}),Object.defineProperty(A,"OPEN",{enumerable:!0,value:R.indexOf("OPEN")}),Object.defineProperty(A.prototype,"OPEN",{enumerable:!0,value:R.indexOf("OPEN")}),Object.defineProperty(A,"CLOSING",{enumerable:!0,value:R.indexOf("CLOSING")}),Object.defineProperty(A.prototype,"CLOSING",{enumerable:!0,value:R.indexOf("CLOSING")}),Object.defineProperty(A,"CLOSED",{enumerable:!0,value:R.indexOf("CLOSED")}),Object.defineProperty(A.prototype,"CLOSED",{enumerable:!0,value:R.indexOf("CLOSED")}),["binaryType","bufferedAmount","extensions","protocol","readyState","url"].forEach((e=>{Object.defineProperty(A.prototype,e,{enumerable:!0})})),["open","error","close","message"].forEach((e=>{Object.defineProperty(A.prototype,`on${e}`,{enumerable:!0,get(){const t=this.listeners(e);for(let e=0;e<t.length;e++)if(t[e]._listener)return t[e]._listener},set(t){const r=this.listeners(e);for(let t=0;t<r.length;t++)r[t]._listener&&this.removeListener(e,r[t]);this.addEventListener(e,t)}})})),A.prototype.addEventListener=q,A.prototype.removeEventListener=G,f=A};
